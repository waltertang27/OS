CHECKPOINT 3.1

Description: The keyboard interrupt handler was printing twice to the screen, once with the character, and right after with a space. 
Where: keyboard.c
Issue: Releasing a key also counts as a keypress, which was causing it to register twice. 
Solution: We added an if-statment to check if the keyboard press data byte was a release key, and if it was, we did not register it.

Description: After fixing the bug above, the keyboard was not displaying values to the screen.
Where: keyboard.c 
Issue: After checking if the keypress was not valid and returning, I forgot to set the interrupt flag and send_eoi.
Solution: Added a sti() and send_eoi(1) so that the interrupts would properly be addressed after a keypress.  

Description: The RTC handler was not properly being accessed and would not work with the tests in lib.causing
Where: rtc.c, i8259.c 
Issue: The secondary PIC was not being properly enabled
Solution: We enabled_irq(2) in i8259_init so that the secondary PIC was being properly enabled

Description: When the keys were being stressed tested (spammed), there would be a General Protection Exception raised.
Where: keyboard.c, intr_link.S 
Issue: The assembly linkage was not being done correctly which caused issues with the keyboard
Solution: We fixed the intr_link.S by adding an iret statement.

Description: Addresses allocated are not correct
Where: paging.c
Issue: page_directory array does not allocate to correct page_table addresses. We think this is because there are not enough bits for the address
Solution: We divided the addresses by ALIGN_BYTES (4kb).

Description: test_debug goes back to its starting screen whenever paging_init() is called
Where: kernel.c, paging.c
Issue: After investigating, we found out there are only 31 bits allocated in the page directory struct.
Solution: We added a bit called "unused" to fill the 32-bit page directory struct.

CHECKPOINT 3.2

<<<<<<< HEAD
=======
Description: directory_read does not put the correct file type and file size in the dentry
Where: fs_system.c
Issue: INode addresses are not calculated correctly.
Solution: After updating some code (specifically this line: startINode = (INode_t *)(fs_start + FOURKB)) we can print out some file sizes (but the sizes are not correct).
Then we shifted the inode numbers by three and now we are able to print the correct file sizes.

Description: read_data does not work properly. 
Where: fs_system.c
Issue: INode addresses are not calculated correctly, while loop is causing problems (# of bytes read is not updated properly), writing to the wrong buffer address 
(should be buf + bytes)
Solution: as of 3/28 4pm we haven't solved the issue yet.

Description: system_x is not equal to 0
Where: terminal.c
Issue:
Solution:


>>>>>>> 11b68a76ebfb87ae7bbd047ab5e5930d2ae6fa0d
